# skill-tree

本质是通过将简要知识串联起来，形成自己的一个技能树、融会贯通。

[TOC]

> 2024 年初 33k 50W
> 项目架构 业务技术 架构 项目管理项目实践 缓存设计 消息队列的情景与设计提前准备面试相关回答针对同一个问题，从更深层次的角度去看
> 面试：全局把控
> 思维方式，格局，处理事情的态度方法
>
> 基础能力设计模式架构能力为什么这样设计，这样设计的好处结合业务思考

学习计划进度表

| 科目             | 进度 |
| ---------------- | ---- |
| MySQL            | ✅    |
| Redis            | ✅    |
| Kafka            | ✅    |
| 分布式系统       | ✅    |
| 操作系统         | ⭐️    |
| 网络             |      |
| JUC              | ⭐️    |
| 云原生           |      |
| 软件设计         |      |
| 源码解析         |      |
| 性能优化         |      |
| 算法             |      |
| Go               |      |
| 面试相关         |      |
| 大数据           |      |
| netty、nginx、es |      |
| Python           |      |



# **一.基础学科**

## 操作系统
进程管理

- 进程&线程&协程

  进程是资源分配的基本单位，而线程是程序执行的基本单位(内存占用和线程切换(内核态)。

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/9d4e3f26e3a741c780fb0d951d49fa9b.png)

  协程的出现是为了降低线程创建的时间和空间成本，以及回归到同步IO的编程模式。

  协程是在用户态下进行切换以及较少的内存占用

- 进程状态

  - 创建、准备、运行、结束、阻塞

- 进程调度算法

  - 抢占式&非抢占式
  - Round-Robin算法
  - 普通进程调度
  - 先来先服务
  - 短作业优先 
  - 最短剩余时间优先


- 线程通信方式
  - 管道、信号、消息队列、socket
- PCB


内存管理

- 内存管理方式

  -  MMU 内存管理单元，存储在CPU中

     -  TLB：MMU中高速缓存

  -  虚拟内存

     虚拟内存是为了保护每个进程所使用的内存空间数据安全。

  -  分段机制

  -  分页机制

  -  Swap机制

     -  换出  内存不够时，将内存中的数据写入到磁盘
     -  换入  内存充足是，将磁盘的数据写入到内存中

  -  段页机制

  -  多级页表和大页

     为了解决页表过多引入多级 

- 局部性原理

  局部性原理分为时间局部性和空间局部性，本质是为了硬件成本与文件读写速度之间的平衡，将高频热点数据存储在高速缓存中。以此提升整体的性能。但是本身也引入了缓存，需要注意缓存命中率与淘汰策略。

- 用户态与内核态、系统调用(中断)、

- 实模式与保护模式

  实模式：直接操作物理地址，但是不安全、内存不够

  保护模式：缺页中断，通过引入虚拟内存及其缺页机制，CPU 很好地解决了操作系统和软件的配合关系。

- 页面置换算法

  -  随机页面置换算法
  -  最优页面置换算法
  -  **FIFO** 算法
  -  **LRU** 算法				 		

文件系统

- 硬连接、软链接
- 磁盘调度算法

网络通信

- 套接字 socket

输入输出系统

死锁

- 死锁
- 产生条件
- 解决方案、模拟死锁

性能优化

- 零拷贝 / pageCache / 异步IO、直接IO

  零拷贝是通过减少用户态到内核态数据的拷贝次数，以及提升数据的复制速度，文件从磁盘到内核缓冲区到网络socket缓冲区。

  而pageCache是操作系统为了提升文件到读写，会先从pageCache中查询数据，如果有直接返回，没有再从磁盘读取数据，而写的过程也是一样的，写入pageCache，然后在同步回磁盘，以及提升读写性能。

  异步IO、直接IO是为了解决大文件在零拷贝下的瓶颈，而推荐使用零拷贝。
  
- COW (Cop On Write)

- IO多路复用

## 网络协议

网络基础

- 网络分层结构
- 常见网络协议

物理层链路层

- MAC
- 交换机与VlAN
- ICMP与PING
- 网关
- 路由协议

传输层

- TCP
- UDP
- 套接字Socket

应用层

- HTTP
- HTTPS
- 流媒体
- P2P

数据中心

- DNS
- HTTPDNS
- CDN
- 数据中心
- VPN
- 移动网络

云计算网络

容器网络

## 数据库

ACID、三范式

索引

锁

事物和隔离级别

存储引擎

日志

SQL优化

高性能

- 读写分离（主从复制）
  - 复制方式（带来的数据不一致性） 本质就是快照+操作日志
    - 同步复制 ：性能不好，不丢失数据
    - 异步复制：性能好，但是可能丢失数据
    - 半异步复制：性能稍微好，同步至少一台从库机器。
  - 复制状态机
- 表数据复制
- 分库分表
  - 数据量大就分表，并发高就分库
  - 范围分片(容易热点数据)、哈希分片（数据比较均匀）、查表法（性能差）

高可用

​    高可用依赖的是数据复制，数据复制复制就是从一个库备份数据，然后恢复到另一个库中

- 数据备份：

  全量备份 mysqldump -u root -p test > test.sql

  增量备份 binlog

- MySQL HA

  | 方案                              | 高可用 | 可能丢数据 | 性能 |
  | --------------------------------- | ------ | ---------- | ---- |
  | 一主一从<br /> 异步复制、手动切换 | 否     | 可控       | 好   |
  | 一主一从<br />异步复制、自动切换  | 是     | 是         | 好   |
  | 一主二从 <br />同步复制、自动切换 | 是     | 否         | 差   |

## 数据结构与算法
### 数据结构

数组

链表

- 跳表

栈

- 单调栈

队列

树

- BST
- Trie
- 红黑树
- B树
- B+树

哈希表

字符串

- KMP

图

布隆过滤器

堆

### 算法

排序

- 快排、归并

二分

搜索

- BSF
- DFS
- 回遡

贪心算法

动态规划

位运算

数学

双指针

滑动窗口

LRU

## 软件工程
## Linux 

目录操作

- cd / pwd / open / mkdir / rmdir / ls 

文本操作

- cat、head、tail、less、more、wc -l  查看文件行数
- vim 、rm -rf、find、

系统管理

- su - 切换用户  
- sudo 以其他用户身份执行命令
- kill -9 杀死进程

系统资源查询

- ps、ps -ef、pstree、netstat、df 、top、free
- free
  - cache是对文件系统的缓存、buffer是对磁盘的缓存。

进程管理



## 程序员素养/数学
## 密码学
# 二.编程语言
## Java

集合类

字符串

OOP

关键字

异常

IO

范型

反射

序列化

java8

注解

枚举

## Go
## python
## JVM

类加载器/流程

字节码技术

JVM对象分配回收策略

运行时数据区

垃圾回收算法

垃圾收集器

JVM调优

## 并发编程
并发基础

- 进程&线程
- 线程状态 
- 线程创建

互斥同步

- synchronized
  - 锁升级 & mark word 
    - 无锁->偏向锁->轻量级锁->重量级锁
    - 本质：因避免无效的锁竞争，提升整体的并发性能。
- ReentrantLock
  - ReentrantReadWriteLock
    - 读写锁，锁降级（写锁降级为读锁）
  - StampedLock
    - 通过版本进行标记，乐观的读 

线程协作/通信

- join
- wait/notify/notifyAll
- awit/singal/singalAll
- LockSupport

AQS

- AQS源码解析整体流程

  大概的整体流程是这样的，首先，我们创建三个线程A,B,C。线程A先拿到锁，执行任务。 而B、C一直获取不到锁，不能执行任务。被park。等A指向完毕之后，unpark(B);

  lock.lock() 线程A通过CAS 设置上锁。而等线程B去获取锁的时候，CAS获取不到锁。于是进入acquire(1)进入nonfairTryAcquire 再次尝试获取锁，获取不到、直接返回 false。进入addWaiter()将当前节点添加到队列中enq(node)，因为t==null ，所以先创建一个哨兵结点。然后第二次自旋，将当前节点Node(ThreadB)，添加到队列中。调用 acquireQueued() ，拿到当前节点的前置节点。第三次获取，获取不到。进入 park() 等待。等待线程释放锁， unpark() 操作。而在此时，线程A执行任务完毕，进行 lock.unlock() 操作。执行 release(1) ,通过head节点将下一个节点进行 unpark() 操作。而因为线程B被park()了，所以下一次就可以获取到锁，将队列中的哨兵结点进行修改。

工具类

- CountDownLatch
- CyclicBarrier
- Semaphore
- Future
- CompletableFuture
  - 异步编程+回调

JMM

线程安全

锁

- 乐观锁
  - 适用场景：读多写少，会认为数据不会修改，性能高。如果出现修改，在使用CAS或者version进行判断。
  - 实现方式 version版本和CAS
- 悲观锁
  - 适用场景：写多读少，先加锁然后在操作。
  - syn和lock
- 公平锁/非公平锁
- 可重入锁
- 死锁
- 写锁/读锁
- 自旋锁
- 无锁->偏向锁->轻量级锁->重量级锁 （syn锁升级）
- 无锁->独占锁->读写锁->邮戳锁  (锁降级)

线程池原理

threadlocal原理

- 原理 ：**线程间变量隔离**

  为了解决线程内数据跨方法类的调用，使用类threadlocal，具体就是thread包含一个threadlocal，而threadlocal内部包含一个threadlocalMap对象。key为this (threadlocal) vaule为对应的值。为了保证引用可以被删一个是程序内部使用弱引用，而是通过程序员remove（）进行维护删除，以及来保证内存泄露。

## 网络编程

同步：调用者需要等待函数的返回结果，才可以继续执行。

异步：调用者无需等待函数的返回结果，可以继续执行，但是一般都是通过回调函数进行通知。

同步vs异步：在于被调用者结果的通知方式，同步无需通知，异步需要进行回调。

阻塞：调用放一直等待结果，当前线程刮起，啥都不能干

非阻塞：调用方可以直接处理别的事情。

阻塞vs非阻塞：在于调用方等待消息时候的行为，是否可以做的别事情

BIO：**BIO的特点就是在IO执行的两个阶段都被block了。**

NIO：**NIO特点是用户进程需要不断的主动询问内核数据准备好了吗？一句话，用轮询替代阻塞！**

IO多路复用 
![image](https://github.com/qxlx/skill-tree/assets/36980092/22a9b41f-9834-4199-9f7e-f7cf3d417214)


信号驱动IO

异步IO

### 异步 I/O 模型

### IO多路复用

select

poll

epoll

### C10K

C10K 问题本质上是操作系统处理大并发请求的问题。对于 Web 时代的操作系统而言，对于客户端过来的大量的并发请求，需要创建相应的服务进程或线程。这些进程或线程多了，导致数据拷贝频繁（缓存 I/O、内核将数据拷贝到用户进程空间、阻塞）， 进程 / 线程上下文切换消耗大，从而导致资源被耗尽而崩溃。这就是 C10K 问题的本质。

# 三.开发框架
## web框架
## ORM
## Spring

Spring循环依赖

- 循环依赖是在SpringBean初始化声明周期而产生的问题

  整体流程，其实就是A创建的过程中需要B，所以将A对象自己放入三级缓存中，然后去实例化B。
  2.B在实例化的时候，发现自己引用了属性A，所以从三级缓存中依此查询，查询一级缓存没有，在查询二级缓存也没有，发现三级缓存有，将A从三级缓存放入二级缓存，并将三级缓存中的A删除。
  3.B创建完毕之后，将自己放入一级缓存中。然后A接着创建，直接从一级缓存中获取B。A创建完成，将自己放入一级缓存中。
  整个过程其实就是依赖于如果发现是循环依赖的话，通过将对象提前暴露出来，存储缓存中，并且scope=singleton。所以可以解决这个问题。

Bean生命周期

bean初始化流程

AOP原理

IOC原理

Spring MVC原理

Spring中设计模式

## Spring-cloud

Nacos

OpenFeign

Gateway

sentinel

# 四.中间件
## RPC/注册中心

Zookeeper

## 网关/代理

Nginx

## NoSQL
## 缓存
### Redis

![](https://img-blog.csdnimg.cn/a0b5b20bd1224d06814f1410019461c8.png)

Redis基本命令

底层数据结构

Redis高性能IO模型

IO多路复用

持久化

- AOF
- RDB

双写一致性

雪崩、击穿、穿透、预热

布隆过滤器

分布式锁

高可用

Redis数据同步、复制

Redis哨兵机制

Redis哨兵集群

Redis切片集群

## 消息队列

消息队列作用

- 异步、削峰、解耦、提升写性能

带来的问题

- 消息延迟、系统的复杂度、数据不一致（消息顺序、消息丢失、重复消费、消息挤压、高可用、高性能）

### Kafka

Kafka基础架构

- Broker->Topic->Partition->Partition Leader-> Partition Follower 
- 部署架构：单机模式/集群模式

分区机制

- 作用提升负载均衡、可伸缩能力、提升系统处理写性能
- 策略：随机、轮询、按消息键保序、其他策略

消息挤压如何处理

- 优化性能避免消息挤压
  - 发送端性能优化
    - 准备数据、序列化数据、之前的耗时
    - 发送消息和返回响应网络传输中的耗时
    - Broker处理消息的时延
  - 消费端性能优化
    - 优化消费端程序业务逻辑性能
    - 水平扩容，增加消费端并发数据。加机器，分区。
- 发送快了，消费变慢了
  - 监控、紧急消费端扩容、关闭上游系统功能、错误日志、同一条消息反复消费，拖垮整个系统

消息重复消费

- 生产者幂等、消费者幂等

消息可靠传输

- 发送、存储、消费三个阶段

生产者消费流程

Kafka如何实现高性能

- 批量发送、顺序读写提升磁盘IO性能、PageCache加速消息读写、零拷贝技术

**Kafka消费者分区分配和重平衡 ⭐️**

消费者位移

副本机制

Kafka多线程消费

Kafka高水位和Leader Epoch原理

### RabbitMQ

## 搜索引擎 
 ### ES

## 配置中心

### Apollo
### XDmond
## 定时

### XXL-JOB

## 监控/报警/日志

## 链路

### FalCon

# 五.软件设计

![img](https://static001.geekbang.org/resource/image/f3/d3/f3262ef8152517d3b11bfc3f2d2b12d3.png)

## 编程范式

类型系统

范型编程

面向过程

面向对象

- 封装、抽象、继承、多态
- 接口 VS 抽象类

函数式编程

原型编程

编程本质

## 规范

编码规范

## 重构

- 单元测试
- 可测试性
- 大重构
- 小重构

## 设计原则
单一职责原则-SRP

开闭原则-OCP

里氏替换原则-LSP

接口隔离原则-ISP

依赖倒置原则-DIP

Don’t Repeat Yourself (DRY) 原则

Keep It Simple, Stupid (KISS)原则

Program to an interface, not an implementation

You Ain’t Gonna Need It (YAGNI) 原则

Law of Demeter，迪米特法则 (Law of Demeter)原则

## 设计模式

### 创建型

单例模式

工厂模式

建造者模式

原型模式

### 结构型

代理模式

桥接模式

装饰者模式

适配器模式

门面模式

组合模式

享元模式

### 行为型

观察者模式

模板模式

策略模式

职责链模式

迭代器模式

状态模式

访问模式

备忘录模式

命令模式

解释器模式

中介模式

## 源码解析

TomCat源码解析

## DDD&MVC
# 六.架构设计

架构设计三原则、简单、合适、演化。**面向复杂度设计**
![img](https://img-blog.csdnimg.cn/a2e7e82a740c49d79c0d5f1d50cae3d4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXhseGk=,size_20,color_FFFFFF,t_70,g_se,x_16)
![img](https://img-blog.csdnimg.cn/2ab8c7fae2894781899ceac595beec6e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXhseGk=,size_20,color_FFFFFF,t_70,g_se,x_16)
- ![image](https://github.com/qxlx/skill-tree/assets/36980092/df11e9cd-d3e5-4e49-93d8-4b72de63e0d2)
![image](https://github.com/qxlx/skill-tree/assets/36980092/b86f37cf-5a9f-4d37-a4e7-cab9bd595395)

## 微服务

## 分布式理论

BASE

- **Basic Availability**：基本可用。这意味着，系统可以出现暂时不可用的状态，而后面会快速恢复。
- **Soft-state：**软状态。它是我们前面的“有状态”和“无状态”的服务的一种中间状态。也就是说，为了提高性能，我们可以让服务暂时保存一些状态或数据，这些状态和数据不是强一致性的。
- **Eventual Consistency：**最终一致性，系统在一个短暂的时间段内是不一致的，但最终整个系统看到的数据是一致的。

CAP

- 一致性 (Consistency)  **强调的是各节点间的数据一致**
- 可用性 (Availability)
- 分区容错性 (Partition Tolerance)  **强调的是集群对分区故障的容错能力**

ACID

ACID的目的其实是为了保证数据的一致性，但是这种一致性是强一致性，在单机系统下可以很好的实现，但是放在分布式系统中，我们很难去权衡系统之间可用和数据的强一致性。而[分布式事务]需要通过二阶段提交协议和TCC（Try-Confirm-Cancel）实现。

- 原子性（Atomicity）：整个事务操作过程中，要么是整体成功的，要么是整体失败的，不可能出现一半成功一半失败。如果出现异常的话，那么需要进行回滚到最原始的状态。举一个例子来说，比如我们在一个大事物中同时操作了订单和支付的表，那么当出现异常的情况，比如说三方异常或者是内部系统错误，事务会进行回滚到原始的状态。
- 一致性(Consistency）: 在事务执行的前后，数据的完整性约束没有破坏。
- 隔离性（Isolation）： 两个事务之间不会互相干扰，即一个事务A不会看到另一个事务B的中间数据。
- 持久性（Durability）： 当事务完成之后，数据会被持久化到磁盘中，并且出现机器宕机等可以进行数据的恢复

我们知道在分布式系统中不同的业务其实并不需要完全的数据一致性，大对数场景中，我们必须保证的是核心链路的稳定性、可用性，所以BASE其实就是CAP的一个变种。倾向于设计出一个更富有弹性能力的系统。
在分布式系统中故障是不可避免的，当出现分区或者故障的时候，我们应该在设计层面多去考虑可能出现的问题，把故障处理当成功能写入代码中，即Design for Failure。新手与老手的差别就是新手可能会完整基本功能就可以了，但是老手会考虑很多边界问题，不和合法性以及可能出现的各种异常问题。
举一个例子：比如买书，ACID的玩法是将库存锁住，不可能同时多个用户购买，而BASE的玩法是异步处理，可以支持用户抢购。
ACID是酸、BASE是碱，从本质上来说ACID的C强调的是一致性（CAP中C），而BASE强调的是可用性（CAP中A）
关注点也不一样：ACID关注的是数据的完整性，而CAP的C关注的是分布式节点的数据一致性。

![在这里插入图片描述](https://img-blog.csdnimg.cn/eb065973d6d94c36a988d4cfcbd36f14.png)

FLP

- 很多人知道CAP、ACID、BASE 但是却不了解FLP，这里为了文章的完整性，介绍一下

  FLP是分布式领域中非常著名的定理，在异步通讯场景中，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性。

  限定条件

- 确定性协议：给定一个输入，一定会产生相同的输出。
- 异步网络通讯：同步通信：同时在线，允许超时，异步通信，没有统一时钟，不能时间同步，不能使用超时，消息可任意延时，乱序。
- 所有存活节点：所有存活的节点必须最终到达一致性。

**ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸**

![在这里插入图片描述](https://img-blog.csdnimg.cn/01f53a6786694d9480f4407be644fd41.png)

两将军

- 两将军问题，主要描述的是有两个军队A和B，分别驻扎在山谷的两侧，同时进攻城市。但是两个军队进攻时间是不确定的，也就是两边军队的Leader没有对发起进攻的时间形成一致。如果任意一方发起，另一方不发起进攻，那么就会失败。想要达成共识的办法就是通过发送信使的通知对方，但是中间的山谷被敌军占领。

  假设军队Aleader指派了一名通讯兵去通知军队B 明天8点发起进攻，但是很可能这个通讯兵在中途被敌军擒获。如果没有擒获的话，军队Bleader为保证自己收到消息，需要给军队A发送消息，我已经收到了明天8点一起发起总攻。但是这个通讯兵在路上也可能被擒获。即使两边一次不停的发送也没有办法保证消息自己的通讯兵没有被擒获。所以这个问题是无解的。

  说白了，在两将军问题中，信道是不可靠的，但是如果从工程角度解决的话，并不会去尝试解决信道不可靠问题，而是将这个不可靠降低到一个可接受的程度，三次握手机制其实是没有办法保证网络连接的可靠性，只是说在基于网络连接可靠的情况下，通过客户端和服务端的请求-相应-确认机制去确保连接建立成功。

拜占庭将军

- 拜占庭问题其实描述的是在拜占庭，周边有多个军队，想要一起进攻，必须每个军队就进攻/不进攻达成一致，但是再次基础上，军队中存在敌军间谍，会扰乱左右决策的过程，从而导致最终结果不一致。说白了拜占庭问题就是，在已知有敌军间谍的情况下，在忠勇将军的不受判读的影响下如何达成一致的协议。
  拜占庭将军问题是两将军问题的升级版本，除了存在故障行为，还可能存在恶意行为。所以一般使用的话在数字货币的区块链技术中需要使用拜占庭容错算法。BFT。

## 共识算法

一致性与共识

- 分布式共识就是在多个节点均可独自操作或记录的情况下，使得所有节点针对某个状态达成一致的过程。通过共识机制，我们可以使得[分布式系统]中的多个节点的数据达成一致。
- **一致性强调的是结果，共识强调的是达成一致的过程**

Paxos

Raft

ZAB

Gossip

## 分布式计算

## 分布式存储

分布式ID

分片

- **分片或者分区的本质是为了解决单机存储和性能瓶颈带来的问题，让分布式系统的计算和存储能力可以线性扩展。而数据复制解决的是数据的高可用**
- 水平分片/ 垂直分片 / 混合分片
- 算法：范围分片、哈希分片、一致性哈希分片、**基于虚拟节点的一致性哈希算法**

复制

- **为保证高可用，数据复制就会涉及到数据之间的拷贝，也就是数据一致性问题**
- 单主复制（同步、异步、半异步复制）
- 多主复制
- 无主复制

事务

**CP+ACID=》刚性事务  适用于数据层** 

**AP+BASE=> 柔性食物  适用于业务层**

- XA 

  - 2PC ：准备、提交

  - 3PC：准备、预提交、提交

- 业务补偿
  - TCC
  - sega
- 最终一致性
  - 消息表
  - 消息队列
  - 最大努力通知

分布式锁

- Redis
- ZK
- MySQL

数据存储和检索

- B+树 ：读多写少
- LSM ：写多读少
- 倒排索引&PageRank ：数据搜索

## 高性能架构

![img](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/assets/a9edeae125a80f381003d8d9d0056317.png)

- 缓存

  从客户端、CDN、网关、服务端、内存、数据库、文件系统、磁盘和CPU 都可以通过加缓存，来提高访问的速度。

- 负载均衡

  水平拓展的技术，通过将用户请求分发到不同的机器上来承担一部分用户流量

- 异步调用

  主要通过消息队列来实现，将前段的请求的峰值给肖平，后端按照自己的速度进行处理请求，增加系统的吞吐量，但是实时性就比较差。但是消息队列带来了消息丢失，重复消费，消息挤压等问题。

- 数据分区/镜像

  数据分区是通过将数据按照某种维度进行划分，比如地理上，请求最近的数据，但是join和跨库的事务操作复杂度比较高。而数据镜像则是通过将数据拷贝一份，然后任意节点上都可以读写，内部自行同步数据，最大问题就是数据一致性问题。

  

  缓存是提高读的性能，而异步调用是提高写的性能，负载均衡技术主要是通过服务冗余将流量进行分担，在分布式架构中，数据存储是一个重中之重，而一般要么就是使用镜像/复制技术，将数据进行拷贝，读写分离，另一种就是将数据分成多片，每片存储在不同服务器上，这样可以横行提高数据读写能力

## 高可用架构

![img](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/assets/befd21e1b41a257c5028f8c1bc7fa279.png)

- 服务拆分

  服务拆分的目的主要是两个，一是隔离故障，二是提高重用性。但是拆分后会引来服务之间依赖通信问题

- 服务冗余

  去除单点故障，支持服务的弹性伸缩，以及故障迁移。具体形式可能是主备、主从。

- 限流降级

  当系统是在扛不住压力的时候，需要通过限流或者降级的方式来保证核心业务的正常运转，属于技术保护的措施。

  接口级别：限流、降级、排队、熔断、超时重试&幂等

- 高可用架构

  通常来说高可用架构是从冗余架构的角度来保证可用性，多租户隔离，容灾备份(异地多活/同城多机房、跨城多机房、跨国多机房)，或者数据可以在复制保持一致性的集群。

  异地多活：同城多机房、跨城多机房、跨国数据中心

  存储高可用：复制（主从、主备、主主）

  计算高可用：负载均衡、任务分配、任务分解

- 高可用运维

  DevOps中的CI/CD（持续集成、持续部署）一个流程的软件发布流程，足够的自动化测试，相应的灰度发布，线上系统的自动化控制。

## 分布式系统的纲

![img](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/assets/8958a432f32dd742b6503b60f97cc3f2.png)



- **服务治理**

  服务拆分、服务调用、服务发现、服务依赖。关键在于对服务调用链路，依赖关系给梳理出来，并对这些服务进行性能和可用性方面的管理

- **软件架构管理**

  服务之间有依赖关系，有兼容性问题，所以整体服务所形成的架构需要有架构版本管理，整体架构的生命周期管理，以及对服务的编排，聚合，事务处理等服务调度功能

- **DevOps**

  分布式服务可以快读的部署，但是对测试和运维是一个挑战，包括环境构建、持续集成、持续部署等

- **自动化运维**

  对服务进行自动伸缩、故障迁移、配置管理、状态管理等一系列自动化运维技术了

- **资源调度管理**

  应用层的 计算 网络 存储

- **整体架构监控**

  监控是眼睛，需要对 应用层、中间件层、基础层进行监控

- **流量控制**

  负载均衡、服务路由、熔断、限流、降级都和流量相关的调度，以及灰度发布等。

分布式五个关键技术

- 全栈系统监控
- 服务、资源调度
- 流量调度
- 状态、数据调度
- 开发和运维的自动化

## 可拓展架构

分层

SOA

微服务

微内核

## 性能调优

性能指标

- TPS、QPS、吞吐量

架构设计

- 缓存、异步、集群、分片、复制
- 网络层面
- 服务器硬件层面
- 操作系统层面
- JVM性能优化
- 基础组件优化（MySQL、Kafka、Redis）
- 软件架构层面优化
- 软件代码优化

如何优化

- 三要三不要
  - 三要
    - 查询系统最大性能瓶颈
    - 确诊问题根本原因
    - 考虑多种情况
  - 三不要
    - 过度反常优化
    - 过早不成熟优化
    - 表面的肤浅优化
- 十大策略
  - 时空转换
    - 空间换时间
    - 时间换空间
  - 并行/异步
    - 并行操作
    - 异步操作
  - 预先/延后处理
    - 预先/提前处理
    - 延后/惰性处理
  - 缓存/批量合并
    - 缓存数据和结果
    - 合并和批处理
  - 算法设计和数据结构
    - 更快的算法设计
    - 更优化的数据结构

## 系统设计

# 七.编程工具

## git

## idea

## Maven

## gradle

# 八.云原生

## CI/CD

软件生命周期

CI/CD

Jenkins

## DevOps

## docker

虚拟化/容器化

基础命令

镜像

compose

container

network

image

volume

swarm

## k8s



# 九.大数据
  实时计算
  离线计算

## Hadoop

## Spark\Filnk

# 十.其他领域

## 区块链     

# 技术管理

## 1.总体介绍

技术的本质：技术是为了解决问题，技术解决问题的一种手段。

三角：技术->业务->产品

技术团队管理的本质 

- 带好团队
- 做好事
- 团队文化

管理思维｜技术思维

- 系统性思维、利他思维、用户思维、trade-off思维

技术管理的能力构成

- 自我管理、商业思维、向上管理、产品思维、同级别管理、跨部门协作、数据思维、业务洞察力、技术敏感和架构决策、项目管理、

## 2.思维方式篇

## 3.制度篇

## 4.人才篇

## 5.团队篇

## 6.组织设计篇

## 7.做事篇

## 8.研发工具效率篇

## 9.技术判断力与决策篇

## 10.自我修养篇

## 11.项目管理篇

## 12.产品篇

## 13.商业思维篇

## 14.管理者能力认识篇

## 15.数据思维篇

# 面试

工作中遇到的那些问题、难点 系统架构图         

     操作系统
       https://segmentfault.com/a/1190000039774784 从根上理解用户态与内核态


