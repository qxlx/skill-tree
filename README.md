# skill-tree

本质是通过将简要知识串联起来，形成自己的一个技能树、融会贯通。

[TOC]

> 2024 年初 33k 50W
> 项目架构 业务技术 架构 项目管理项目实践 缓存设计 消息队列的情景与设计提前准备面试相关回答针对同一个问题，从更深层次的角度去看
> 面试：全局把控
> 思维方式，格局，处理事情的态度方法
>
> 基础能力设计模式架构能力为什么这样设计，这样设计的好处结合业务思考

学习计划进度表

| 科目               | 进度 |
| ------------------ | ---- |
| MySQL              | ✅✅✅  |
| Redis              | ✅✅✅  |
| Kafka              | ✅    |
| 分布式系统         | ✅    |
| 操作系统           | ✅    |
| 网络               | ✅    |
| JUC                | ✅✅✅  |
| Spring             | ✅✅✅  |
| JVM                | ✅✅✅  |
| 云原生             | ⭐️    |
| 软件设计           | ⭐️    |
| 源码解析           | ⭐️    |
| 性能优化           | ⭐️    |
| 算法               | ❎    |
| Go、面试相关       |      |
| netty、nginx、es、 |      |
| Python、大数据     | 24年 |



# **一.基础学科**

## 操作系统
进程管理

- 进程&线程&协程

  进程是资源分配的基本单位，而线程是程序执行的基本单位(内存占用和线程切换(内核态)。

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/9d4e3f26e3a741c780fb0d951d49fa9b.png)

  协程的出现是为了降低线程创建的时间和空间成本，以及回归到同步IO的编程模式。

  协程是在用户态下进行切换以及较少的内存占用

- 进程状态

  - 创建、准备、运行、结束、阻塞
  - 僵尸进程和不可中断进程
  - 表示进程正在跟硬件交互，为了保护进程数据和硬件的一致性，系统不允许其他进程或中断打断这个进程。进程长时间处于不可中断状态，通常表示系统有 I/O 性能问题。
  - 僵尸进程表示进程已经退出，但它的父进程还没有回收子进程占用的资源。短暂的僵尸状态我们通常不必理会，但进程长时间处于僵尸状态，就应该注意了，可能有应用程序没有正常处理子进程的退出。

- 进程调度算法

  - 抢占式&非抢占式
  - Round-Robin算法
  - 普通进程调度
  - 先来先服务
  - 短作业优先 
  - 最短剩余时间优先


- 线程通信方式
  - 管道、信号、消息队列、socket
- PCB


内存管理

- 内存管理方式

  -  MMU 内存管理单元，存储在CPU中

     -  TLB：MMU中高速缓存

  -  虚拟内存

     虚拟内存是为了保护每个进程所使用的内存空间数据安全。

  - 内存泄漏

     - 对于进程来说，其实是内核提供的虚拟内存，虚拟内存需要通过页表，由系统映射为物理内存。**虚拟内存->页表->物理内存。**
        进程通过malloc() 申请虚拟内存后，一般不会立即分配物理内存，在首次访问的时候，才通过缺页异常陷入内核中分配内存。

        为了提升性能，引入了cache和buffer，cache是为了提升文件读写性能，而buffer是为了提升磁盘的读写性能。
        所以整体就是 内存的分配和回收过程。

  - 分段机制

  - 分页机制

  - Swap机制

     -  换出  内存不够时，将内存中的数据写入到磁盘
     -  换入  内存充足是，将磁盘的数据写入到内存中

  - 段页机制

  - 多级页表和大页

     为了解决页表过多引入多级 

- 局部性原理

  局部性原理分为时间局部性和空间局部性，本质是为了硬件成本与文件读写速度之间的平衡，将高频热点数据存储在高速缓存中。以此提升整体的性能。但是本身也引入了缓存，需要注意缓存命中率与淘汰策略。

- 用户态与内核态、系统调用(中断)

  - 上下文切换
    - 进程上下文切换（成本高）
    - 线程上下文切换（私有数据修改）
    - 中断上下文切换
  - 中断调用
    - 硬中断，快速处理中断
    - 软中断，异步处理上半部分没有完成的工作

- 实模式与保护模式

  实模式：直接操作物理地址，但是不安全、内存不够

  保护模式：缺页中断，通过引入虚拟内存及其缺页机制，CPU 很好地解决了操作系统和软件的配合关系。

- 页面置换算法

  -  随机页面置换算法
  -  最优页面置换算法
  -  **FIFO** 算法
  -  **LRU** 算法				 		

文件系统
<img width="517" alt="image" src="https://github.com/qxlx/skill-tree/assets/36980092/999991f2-d82b-454f-ab45-fcbfa98f30f1">

- 索引节点（数据的元信息）、目录项（文件系统树结构）
- VFS 为了支持各种不同的文件系统，Linux 内核在用户进程和文件系统的中间，又引入了一个抽象层，也就是虚拟文件系统 VFS（Virtual File System）。
- 缓存
  - 索引节点缓存、目录项缓存、页缓存、标准库缓存
- 磁盘
  - 超级块、索引节点区、数据块区
- 文件系统，通用设块层、设备

- 硬连接、软链接
- 磁盘调度算法
- 文件系统有自己的索引、文件缓存、文件数据结构、文件描述符

网络通信

- 套接字 socket

输入输出系统

死锁

- 产生条件
  - **资源互斥** 一个资源只能被一个线程使用
  -  **请求与保持条件** 一个线程因阻塞时对以获取的资源不释放 
  - **不剥夺条件** 线程获取的资源 在未使用之前，不能强行剥夺 
  - **循环等待条件** 若干线程之间形成一种头尾相接的循环等待资源关系
- 解决方案、模拟死锁
  - **粗粒度的锁**
  - **锁排序法** 按照获取锁的顺序 来依次获取锁
  - 设置超时时间

性能优化

- 零拷贝 / pageCache / 异步IO、直接IO

  零拷贝是通过减少用户态到内核态数据的拷贝次数，以及提升数据的复制速度，文件从磁盘到内核缓冲区到网络socket缓冲区。

  而pageCache是操作系统为了提升文件到读写，会先从pageCache中查询数据，如果有直接返回，没有再从磁盘读取数据，而写的过程也是一样的，写入pageCache，然后在同步回磁盘，以及提升读写性能。

  异步IO、直接IO是为了解决大文件在零拷贝下的瓶颈，而推荐使用零拷贝。
  
- COW (Cop On Write)

- IO多路复用

## 网络协议
![image](https://github.com/qxlx/skill-tree/assets/36980092/01e38c30-b4ba-4b37-b2cb-f156a220417d)


网络基础

- 网络分层结构
- 常见网络协议

物理层

链路层

- 拓扑结构
  - 解决环路问题：武林比武 STP
  - 掌门遇到掌门、同门相遇、掌门与其他帮派小弟相遇、不同门小弟相遇

- MAC
  - IP是地址，有定位功能；MAC是身份证，无定位功能；
  - CIDR 判断是不是本地人

- 交换机与VlAN
  - 交换机有自我学习MAC地址的能力，学习结果是转发表
  - VLAN：交换机数目多会面临隔离问题，可以通过 VLAN 形成虚拟局域网，从而解决广播问题和安全问题。

- ICMP与PING
  - ICMP全称Internet Control Message Protocol，就是互联网控制报文协议
  - 查询报文类型/差错报文类型

- 网关
  - 静态路由
  - 转发网关 IP不变 MAC改变
  - NAT网关 IP和MAC都需要改变

- 路由协议
  - 配置路由
  - 静态路由
  - 动态路由
    - 距离矢量路由算法  全局存储 
    - 链路状态路由算法 求最短路径 

  - 动态路由协议
    - 基于链路状态路由算法的 OSPF
    - 基于距离矢量路由算法的 BGP

- ARP
  - 已知 IP 地址，求 MAC 地址的协议。
  - 1.查看本地ARP表  2.广播ARP请求  3.ARP应答 4.缓存IP-MAC映射

- CRC 循环冗余检测
  - 通过 XOR 异或的算法，来计算整个包是否在发送的过程中出现了错误


传输层

- TCP
  - 丢包、乱序、重传、拥塞
    - 顺序问题、丢包问题、流量控制都是通过滑动窗口来解决的。
    - 拥塞控制是通过拥塞窗口来解决的。（慢启动+拥塞避免  /快重传+快恢复）
      - 拥塞窗口：这是发送端根据自己估计的网络拥塞程度而设置的窗口值，**是来自发送端的流量控制**。
      - 防止过多的数据注入网络中，使得网络中的路由器或链路不至过载
      - 慢启动
        - 由小到大逐渐增加发送数据量 **发送端的拥塞窗口数值**，每收到一个报文确认，就加一。**指数级增加**
        - 窗口 cwnd 的增长引起网络拥塞，还需要慢开始门限 ssthresh。
        - 当 cwnd<ssthresh,使用慢开始算法; 当 cwnd>ssthresh,，使用拥塞避免算法；cwnd=ssthresh,既可用慢开始算法也可用拥塞避免算法。
        - 无论是慢开始还是拥塞避免，只要发送端发现网络阻塞，就将慢开始门限设为出现拥塞时的发送窗口值的一半，然后拥塞窗口为一，并执行慢开始算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕
      - 拥塞避免
        - 当网络中的资源供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降，也就是说对资源的需求超过了可用的资源，因为传输数据是需要资源的。
      - 快重传
        - 快重传算法规定：发送端只要一连收到三个重复 ack，即可断定有分组丢失，就应该立即重传丢失的报文，而不需要等待为该报文设置的重传计时器超时。
        - 与慢开始不同，拥塞窗口不设为 1，,而设为慢开始门限+3*mss（mss：最大报文段）。

    - 流量控制和拥塞控制的理解吗？
      - 流量控制考虑点对点的通信量的控制，也就是客户端和服务端直接数据传输数据量的大小。
      - 拥塞控制考虑的问题是整个网络，是全局性的考虑。

  - 三次握手
  - 四次挥手
    - MSL

  - TCP状态机

- UDP
  - 格式
    - 源端口号+目标端口号、UDP长度、UDP校验和

  - 区别：TCP是面向连接的，UDP是无连接的
  - TCP提供可靠交付，IP层其实没有保证数据的可靠性，TCP传输层保证来传输的数据，无差错、不丢失、不重复，并且按序到达。而UDP不保证可靠传输。并且不按顺序到达
  - TCP是面向字节流，发送的是一个一个的流，UDP是一个一个的数据报。
  - TCP具备拥塞控制，也就是会根据丢包以及网络稳定情况进行调整自己发送数据的快慢。UDP其实不管三七二十一，只管发送
  - TCP是一个有状态服务。会明确记录包又没有到达，UDP是无状态的服务。
  - 使用场景
    - 网络情况比较稳定的情况 或者对于丢包场景不敏感的应用
    - 流媒体的协议、实时游戏、IOT物联网等

- 套接字Socket
  - 基于TCP、基于UDP
  - 套接字、多进程、线程、IO多路复用等


应用层

- HTTP
  - 请求行
  - HTTP2

- HTTPS
  - 对称加密和非对称加密
  - https 其实是由两部分组成：http+ssl/tls，也就是在 http 上又加了一层处理加密信息的模块，服务端和客户端的信息传输都会通过 tls 加密，传输的数据都是加密后的数据。加解密过程：
    1）客户端发起 https 请求（就是用户在浏览器里输入一个 https 网址，然后连接到 server的 443 端口）
    2）服务端的配置（采用 https 协议的服务器必须要有一塔数字证书，可以自己制作，也可以向组织申请，这套证书就是一对公钥和私钥）。
    3）传输证书（这个证书就是公钥，只是包含了很多信息）
    4）客户端解析证书（由客户端 tls 完成，首先验证公钥是否有效，若发现异常，则弹出一个警示框，提示证书存在问题，若无问题，则生成一个随机值，然后用证书对随机值进行加密）
    5）传输加密信息（这里传输的是加密后的随机值，目的是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密了）
    6）服务端解密信息（服务端用私钥解密后得到了客户端传来的随机值，then 把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全）
    7）传输加密的信息
    8）客户端解密信息，用随机数来解。

- 流媒体
- P2P
- DHCP
  - Dynamic Host Configuration Protocol，动态主机配置协议）是一个局域网的网络协议，UDP协议，67号端口
  - 作用就是动态分配IP地址
  - 工作方式：发现->提供->请求->确认。


数据中心

- DNS

  - 域名解析

    - DNS 是一个分布式数据库系统，**存储了域名和 IP 地址的映射关系**。

      **主机向本地域名服务器的查询采用递归查询**：如果本地域名服务器不知道被查询域名的 IP 地址，就会以 DNS 客户的身份向其他根域名服务器继续发出查询请求。

      **本地域名服务器向根域名服务器查询采用迭代查询**：根域名服务器会告知顶级域名服务器的地址，顶级域名服务器给出 IP 地址，或者告知下一步应该向哪个权限域名服务器进行查询。

      - 客户机->Host文件->本地DNS服务区->根DNS服务器->TLD DNS服务器->权威服务器
      - 改善时延性能并减少在因特网上到处传输的DNS报文数量。

  - 负载均衡

- HTTPDNS

  - HTTP+DNS

- CDN

  - 网络加速
  - 边缘节点->区域节点->边缘节点

- 数据中心

- VPN

- 移动网络

云计算网络

- PXE 
  - 预启动执行环境（Pre-boot Execution Environment

容器网络

## 数据库

ACID、三范式

逻辑架构

- 客户端-》连接池->缓存-解析器、优化器、存储引擎

索引

- 结构：avl b b+树
- 场景、失效、sql索引
- 数据结构
  - B+树、Hash、Full-text索引

- 物理存储
  - 聚簇索引和二级索引
  - 回表操作->覆盖索引避免

- 字段特性
  - 主键索引、唯一索引、普通索引、前缀索引

- 字段个数
  - 单列索引和联合索引

锁

- 全局锁
  - `flush tables with read lock;` `unlock tables;`

- 表锁
- 行锁 
  - 锁定范围
    - InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索的数据， InnoDB才使用行级锁，否则，InnoDB将使用表锁。
    - 记录锁：锁定索引中一条记录
    - 间隙锁：锁住一个区间，比如(10,15)
      - 可以防止幻读、保证索引间隙不会插入数据

    - 临键锁：记录锁+间隙锁
    - 插入意向锁：做insert操作时添加的对记录id的锁

  - 功能
    - 读锁
    - 写锁

  - 对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加写锁
  - 对于普通SELECT语句，InnoDB不会加任何锁


事物和隔离级别

- ACID

- 隔离级别

  - | 脏读        | 不可重复读 | 幻读 |      |
    | ----------- | ---------- | ---- | ---- |
    | 1. 读未提交 | P          | P    | P    |
    | 2. 读已提交 | S          | P    | P    |
    | 3.重复读    | S          | S    | P    |
    | 4.序列化    | S          | S    | S    |

- 为了解决可重复读下的幻读问题

  - MVCC+间隙锁
  - 已提交事务++未提交事务+为开始事务
    - 快照读+当前读
    - trx_id + roll_pointer  read_view 
    - 版本未提交，不可见；
    - 版本已提交，但是是在视图创建后提交的，不可见；
    - 版本已提交，而且是在视图创建前提交的，可见。


存储引擎

- innodb myisam 
- 内存结构
  - buffer pool
  - 自适应哈希
  - change buffer 
  - log buffer
  - 磁盘结构
    - 系统表空间->段->区->页(16k)-行数据
    - Redo log
      - 写入时机   定时、提交写、提交写os cache

  - 脏页-> check point解决
    -  check point 方式
    - double write 解决check point写失效问题

日志

- InnoDB

  - redolog
    - 事务提交成功，buffer pool数据没有写入磁盘，宕机了，可以用来恢复buffer pool数据
    - 作用：重做日志，保证数据库持久性


  - undolog
    - 事务进行回滚的时候进行操作，恢复buffer pool中的数据
    - 作用：回滚日志，用于维护数据库原子性、实现MVCC


- binlog
  - 用来恢复数据库磁盘里的数据
    - 作用：主从复制、数据恢复等。


SQL优化

- 业务方、表结构设计、sql本身(explain)、索引(男女字段 区分度) 黄金索引三原则  
- 覆盖索引、减少回表操作、索引下推、索引失效(组合索引) 最左匹配、函数计算
- 一条SQL执行过程
  - server层(连接器、缓存层、分析器、优化器、执行器)  存储引擎层
- Join优化
  - Index Nested-Loop Join：INLJ，索引嵌套循环连接
  - Block Nested-Loop Join：BNLJ，缓存块嵌套循环连接
- 最左匹配原则
  - 组合索引、order by、group by
    - using filesort
      - 单路排序&双路排序
- 分页查询 使用索引字段
- Count
  - 字段有索引:count( \* ) ≈ count(1) > count(字段) >count(主键 id) 
  - 字段无索引:count( \* )≈count(1)>count(主键 id)>count(字段)
- 一些原则
  - 代码线上、索引后加
  - 联合索引进来使用覆盖索引
  - 区分度大的字段加索引
  - 长字符串使用前缀索引
  - where 与 order by 优先where
  - 基于慢SQL优化
- 索引失效的场景
  - 类型不匹配 字符串 数字
  - 表达式计算
  - 函数使用
  - like '%xxx'、覆盖索引除外
  - 最左匹配
  


高性能

- 读写分离（主从复制）
  - 复制方式（带来的数据不一致性） 本质就是快照+操作日志
    - 同步复制 ：性能不好，不丢失数据
    - 异步复制：性能好，但是可能丢失数据
    - 半异步复制：性能稍微好，同步至少一台从库机器。
  - 复制状态机
- 表数据复制
- 分库分表
  - 数据量大就分表，并发高就分库
  - 范围分片(容易热点数据)、哈希分片（数据比较均匀）、查表法（性能差）

高可用

​    高可用依赖的是数据复制，数据复制复制就是从一个库备份数据，然后恢复到另一个库中

- 数据备份：

  全量备份 mysqldump -u root -p test > test.sql

  增量备份 binlog

- MySQL HA

  | 方案                              | 高可用 | 可能丢数据 | 性能 |
  | --------------------------------- | ------ | ---------- | ---- |
  | 一主一从<br /> 异步复制、手动切换 | 否     | 可控       | 好   |
  | 一主一从<br />异步复制、自动切换  | 是     | 是         | 好   |
  | 一主二从 <br />同步复制、自动切换 | 是     | 否         | 差   |

## 数据结构与算法

过遍数 

1.理解题意 2.尽可能所有的解 3.测试 

![image](https://github.com/qxlx/skill-tree/assets/36980092/4685403b-fac4-4190-8081-f379221d4189)


时间复杂度

空间复杂度

O(1)、O(N)、O(LogN)、O(N^2)

### 数据结构

数组

链表

- 跳表

栈

- 单调栈

队列

- 优先队列

树

- BST
- Trie
- 红黑树
- B树
- B+树

哈希表

字符串

- KMP

图

布隆过滤器

堆

LRU Cache

### 算法

排序

- 快排、归并

二分

搜索

- BSF
- DFS
- 回遡

贪心算法

动态规划

递归

分治

位运算

数学

双指针

滑动窗口

## 软件工程
## Linux 

目录操作

- cd / pwd / open / mkdir / rmdir / ls 

文本操作

- cat、head、tail、less、more、wc -l  查看文件行数
- vim 、rm -rf、find、

系统管理

- su - 切换用户  
- sudo 以其他用户身份执行命令
- kill -9 杀死进程

系统资源查询

- ps、ps -ef、pstree、netstat、df 、top、free
- IO
  - iostat -d -x 1  总体IO
  - pidstat -d 1  进程IO
  - iotop
- free
  - cache是对文件系统的缓存、buffer是对磁盘的缓存。
- df -i  索引节点磁盘空间
  - cat /proc/meminfo | grep -E "SReclaimable|Cached"  
  - slabtop 
- 系统上下文切换查看
  - vmstat 5 //总体监控
  - pidstat -w 5 //进程监控
  - pidstat -w -u 1 //-w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标
  - pidstat -wt 1 // -wt 参数表示输出线程的上下文切换指标
  - watch -d cat /proc/interrupts //内核中断指标
  
- 中断查看
  - cat /proc/softirqs
  

进程管理

### CPU

- CPU使用率
  - 用户CPU
  - 系统CPU
  - IOWAIT
  - 软中断
  - 硬中断
  - 窃取CPU
  - 客户CPU
- 上下文切换
  - 自愿上下文切换
  - 非自愿上下文切换
- 平均负载
- CPU缓存命中率
![image](https://github.com/qxlx/skill-tree/assets/36980092/9a1f076c-2887-460a-9996-7a402a6be081)

![image](https://github.com/qxlx/skill-tree/assets/36980092/7a442828-0c07-4712-94e5-18a70718f3b8)

![image](https://github.com/qxlx/skill-tree/assets/36980092/dda46b7b-34b6-4751-8813-b6e591441e47)

### 内存

- 系统内存指标
  - 已用内存
  - 剩余内存
  - 可用内存
  - 缺页异常
    - 主缺页异常
    - 次缺页异常
  - 缓存/缓冲区
    - 使用量
    - 命中率
  - Slabs
- 进程内存指标
  - 虚拟内存(VSS)
  - 常驻内存(RSS)
  - 按比例分配共享内存后的物理内存(PSS)
  - 独占内存
  - 共享内存
  - SWAP内存
  - 缺页异常
    - 主缺页异常
    - 次缺页异常
- SWAP
  - 已用空间
  - 剩余空间
  - 换入速度
  - 换出速度
  ![image](https://github.com/qxlx/skill-tree/assets/36980092/fbf970e9-4639-49a5-94d9-9fb03862070b)

![image](https://github.com/qxlx/skill-tree/assets/36980092/a966d0d5-438c-43be-81ad-2a5aaf0e7a5e)

![image](https://github.com/qxlx/skill-tree/assets/36980092/0daad362-fe90-4446-8745-fbd4cc059d5b)

### IO

- 文件系统
  - 存储空间容量、使用量以及剩余空间
  - 索引阶段容量、使用量以及剩余量
  - 缓存
    - 页缓存
    - 目录项缓存
    - 索引阶段缓存
    - 具体文件系统缓存(ext4缓存)
  - IOPS(文件IO)
  - 响应时间(延迟)
  - 吞吐量
- 磁盘
  - 使用率
  - IOPS
  - 吞吐量(B/s)
  - 响应时间(延迟)
  - 缓冲区
  - 相关因素
    - 读写类型(顺序和随机)
    - 读写比例
    - 读写大小
    - 存储类型(Raid级别、本地、网络)

![image](https://github.com/qxlx/skill-tree/assets/36980092/c1808a9a-d2ff-4226-9d1c-a3b35dc3bb7d)

![image](https://github.com/qxlx/skill-tree/assets/36980092/63e11a70-f82c-416b-b638-c1c7c543814f)


![image](https://github.com/qxlx/skill-tree/assets/36980092/3c3e8b1c-b4ac-47f2-936f-23f36f15591b)



### 网络

## 程序员素养/数学

## 密码学

对称加密

非对称加密

# 二.编程语言
## Java

集合类

- list
  - arraylist linkedlist底层原理 time vs 扩容原理  
- set
  - hashset 
- map 
  - hashmap 原理 扩容 key是如何计算的 hash冲突 
  - concurrenthashmap  	
  - put() get() resize() 三个过程细化
  - 7/8之间的区别 具体问题细化一下 
- HashMap
  - hashmap 的数据结构，扩容时机；
  - concurrentHashMap 和 hashmap 的区别，为什么前者的 key 和 value 都不能为 null；
  - concurrentHashMap 怎么保证的线程安全；
  - concurrentHashMap 扩容过程；

字符串

OOP

关键字

异常

IO

范型

反射

序列化

java8

注解

枚举

## Go
## python
## JVM

类加载器/流程

- 1.类加载的整套流程 说一下你的理解。  加载 验证 准备 解析 初始化
- jvm加载机制  加载过程 加载器  双亲委派模型

- 说一下有哪几个类加载器？ boot /ext / app 
- 双亲委派了解吗？说一下？ 如何判断两个类是否相等
- 类什么时候进行初始化呢？说一下

字节码技术

JVM对象分配回收策略

- a.对象优先eden  b.大对象直接老年代 c. 动态年龄判定 d.长期老年  e.空间担保

运行时数据区

- JVM为什么要分区？那些区域【是否共享】。新、老分别用什么？7.8区别、内存溢出、内存泄漏区别
- 创建对象分配方式  
  - 1.指针碰撞 2.空闲列表  对象内存布局  对象头、实例数据、对其填充
  - 对象访问方式 1.句柄 2.直接指针   
  - 对象是否垃圾 1.引用 2.可达性分析	四种引用
- 四种引用类型  强软弱虚 

垃圾回收算法

垃圾收集器

- GC收集器【串行、并行、并发】

JMM

- JMM内存模型，先行发生原则
- 原子性、可见性、有序性   volatile  执行重排序

JVM调优

- xmx xms  年轻代 老年代比例
- jps ->进程   jstat->信息 jinfo->配置 jmap->内存映像 jhat->堆转储 jstack->堆栈

生产问题排查

- 当一个Java程序响应很慢时如何查找问题、
- 当一个Java程序频繁FullGC时如何解决问题、
- 如何查看垃圾回收日志、
- 当一个Java应用发生OutOfMemory时该如何解决、
- 如何判断是否出现死锁、
- 如何判断是否存在内存泄露

**JVM总体流程为->类加载->运行时数据区创建->内存分配回收策略->GC算法->JVM调优**

## 并发编程

**分工、同步、互斥**

并发基础

- 优势、为什么使用

- 进程&线程
- 线程状态\生命周期  
- 线程创建

互斥同步

- synchronized
  - 基本使用同步方法，同步块
    - 同步方法是通过方法中的access_flags中设置ACC_SYNCHRONIZED标志来实现;同步代码块是通过monitorenter和monitorexit来实现
    - 管程模型
  
  - 对象(对象头(markword、类指针、数组长度)、实例数据、对其填充)
  - 锁升级 & mark word 
    - 001: 无锁、101: 偏向锁、00: 轻量级锁、10: 重量级锁
    - 偏向锁(只有一个线程)
      - 偏向锁延迟
  
    - 轻量级锁
      - 轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间多个线程访问同一把锁的场合，就会导致轻量级锁膨胀为重量级锁
  
    - 偏向锁->无锁  偏向锁->轻量级锁
    - 轻量级锁->无锁  轻量级锁->重量级锁
    - 锁消除、锁粗化
    - 本质：因避免无效的锁竞争，提升整体的并发性能。
  
- ReentrantLock
  - ReentrantReadWriteLock
    - 通过一个变量去控制两个读写锁的状态，位运算的方式
    - 读写锁，锁降级（写锁降级为读锁）
  - StampedLock
    - 通过版本进行标记，乐观的读 

线程协作/通信

- join/yield/sleep
- wait/notify/notifyAll
- awit/singal/singalAll
- LockSupport park和unpark

无锁编程

- CAS、ABA
  - 原子类 
  
    - 基本类型原子类
    - 数组类型原子类
    - 引用类型原子类
    - 对象的属性修改原子类
  
  - LongAdder原理
  
    - CAS+Base+Cell数组分散、空间换时间并分散了热点数据
    - 应用场景：高并发下的全局计算 
    - 条件递增，逐步解析
      	1.最初无竞争时只更新base；
      	2.如果更新base失败后，首次新建一个Cell[]数组
      	3.当多个线程竞争同一个Cell比较激烈时，可能就要对Cell[]扩容
  
  - |          | AtomicLong                                          | LongAdder                                                    |
    | -------- | --------------------------------------------------- | ------------------------------------------------------------ |
    | 线程安全 | 线程安全，有性能损耗                                | 当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用 |
    | 性能     | AtomicLong是多个线程针对单个热点值value进行原子操作 | LongAdder是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作 |
    | 精度     | 保证精度，性能代价                                  | 保证性能，精度代价                                           |
  
- 原理、(独占、共享)Countdownlatch/semaphore/cyclibarrier

AQS

- AQS源码解析整体流程

  大概的整体流程是这样的，首先，我们创建三个线程A,B,C。线程A先拿到锁，执行任务。 而B、C一直获取不到锁，不能执行任务。被park。等A指向完毕之后，unpark(B);

  lock.lock() 线程A通过CAS 设置上锁。而等线程B去获取锁的时候，CAS获取不到锁。于是进入acquire(1)进入nonfairTryAcquire 再次尝试获取锁，获取不到、直接返回 false。进入addWaiter()将当前节点添加到队列中enq(node)，因为t==null ，所以先创建一个哨兵结点。然后第二次自旋，将当前节点Node(ThreadB)，添加到队列中。调用 acquireQueued() ，拿到当前节点的前置节点。第三次获取，获取不到。进入 park() 等待。等待线程释放锁， unpark() 操作。而在此时，线程A执行任务完毕，进行 lock.unlock() 操作。执行 release(1) ,通过head节点将下一个节点进行 unpark() 操作。而因为线程B被park()了，所以下一次就可以获取到锁，将队列中的哨兵结点进行修改。

工具类

- CountDownLatch
- CyclicBarrier
- Semaphore
  - AQS共享模式
    - Semaphore的加锁解锁(共享锁)逻辑实现
    - 线程竞争锁失败入队阻塞逻辑和获取锁的线程释放锁唤醒阻塞线程竞争锁的逻辑实现

  - 限流使用

- Future
- CompletableFuture
  - 异步编程+回调

JMM

- 可见行、有序性、原子性
- happens-before规则、缓存结构、内存屏障

锁

- 乐观锁
  - 适用场景：读多写少，会认为数据不会修改，性能高。如果出现修改，在使用CAS或者version进行判断。
  - 实现方式 version版本和CAS
- 悲观锁
  - 适用场景：写多读少，先加锁然后在操作。
  - syn和lock
- 公平锁/非公平锁
- 可重入锁
- 死锁
- 写锁/读锁
- 自旋锁->自适应自旋 锁消除 锁粗化
- 无锁->偏向锁->轻量级锁->重量级锁 （syn锁升级）
- 无锁->独占锁->读写锁->邮戳锁  (锁降级)

线程池原理

- 线程池原理，线程池组成，拒绝策略，线程池的工作原理，阻塞队列原理、执行流程
- Future、Callable 带返回值的执行
- 阻塞队列

threadlocal原理

- 原理 ：**线程间变量隔离**

  为了解决线程内数据跨方法类的调用，使用类threadlocal，具体就是thread包含一个threadlocal，而threadlocal内部包含一个threadlocalMap对象。key为this (threadlocal) vaule为对应的值。为了保证引用可以被删一个是程序内部使用弱引用，而是通过程序员remove（）进行维护删除，以及来保证内存泄露。

为什么需要多线程->解决了那些问题-> 线程状态/创建 -> 如何保证数据的一致性(同步 syn lock/互斥/cas)-> 线程间通信(wait/notify threadlocal) ->相关锁机制 syn锁升级 ->线程工具类 aqs -> CAS/ABA -> JMM -> 线程池->线程停止

并发设计模式

- 终止线程设计模式
  - 两阶段终止 
    - 另外一个线程去判断，t.interted()
- 避免共享的设计模式
  - Immutability模式- final  (只读)
  - Copy-on-write模式
    - CopyOnWriteArrayList  
  - Thread-Specific Storage模式-没有共享就没有伤害 
    - ThreadLocal
- 多线程版本的if模式
  - Guarded Suspension模式
    - 保护性暂停   Future.get() 等待
  - Baliking模式-
- 多线程分工模式
  - Thread-per-Message 模式
    - BIO 一个线程一个任务
  - Worker Thread 
    - 线程池模型
  - 生产者-消费者模式
    - 阻塞队列

## 网络编程

同步：调用者需要等待函数的返回结果，才可以继续执行。

异步：调用者无需等待函数的返回结果，可以继续执行，但是一般都是通过回调函数进行通知。

同步vs异步：在于被调用者结果的通知方式，同步无需通知，异步需要进行回调。

阻塞：调用放一直等待结果，当前线程刮起，啥都不能干

非阻塞：调用方可以直接处理别的事情。

阻塞vs非阻塞：在于调用方等待消息时候的行为，是否可以做的别事情

BIO：**BIO的特点就是在IO执行的两个阶段都被block了。**

NIO：**NIO特点是用户进程需要不断的主动询问内核数据准备好了吗？一句话，用轮询替代阻塞！**

IO多路复用 
![image](https://github.com/qxlx/skill-tree/assets/36980092/22a9b41f-9834-4199-9f7e-f7cf3d417214)


信号驱动IO

异步IO

### 异步 I/O 模型

### IO多路复用

select ： 将文件描述符，从用户态拷贝到内核态，然后内核将处理好的IO写入文件描述符中。select使用的是bitmap，判断fd的位置那个置为1了。O(N) 时间复杂度。

**select方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（多个文件描述符只有一次 select 的系统调用 + N次就绪状态的文件描述符的 read 系统调用**

- 优点，可以避免多次内核态到用户态的fd的拷贝
- 缺点
  - bitmap默认是1024 长度，只能处理1024个线程。
  - rset每次循环都需要重新置为1，不能重复使用
  - O(N)的时间复杂度

poll

- 优点，解决了只能处理1024个线程的问题。
- 以及reset不可重用

epoll

- 多路复用快的原因在于，操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，

  **变成了一次系统调用 + 内核层遍历这些文件描述符**。

![image](https://github.com/qxlx/skill-tree/assets/36980092/175c72b0-6fa7-4f68-a64d-7b772a06491e)


### C10K

C10K 问题本质上是操作系统处理大并发请求的问题。对于 Web 时代的操作系统而言，对于客户端过来的大量的并发请求，需要创建相应的服务进程或线程。这些进程或线程多了，导致数据拷贝频繁（缓存 I/O、内核将数据拷贝到用户进程空间、阻塞）， 进程 / 线程上下文切换消耗大，从而导致资源被耗尽而崩溃。这就是 C10K 问题的本质。

# 三.开发框架
## web框架
## ORM
## Spring

Spring循环依赖

- 循环依赖是在SpringBean初始化声明周期而产生的问题

  整体流程，其实就是A创建的过程中需要B，所以将A对象自己放入三级缓存中，然后去实例化B。
  2.B在实例化的时候，发现自己引用了属性A，所以从三级缓存中依此查询，查询一级缓存没有，在查询二级缓存也没有，发现三级缓存有，将A从三级缓存放入二级缓存，并将三级缓存中的A删除。
  3.B创建完毕之后，将自己放入一级缓存中。然后A接着创建，直接从一级缓存中获取B。A创建完成，将自己放入一级缓存中。
  整个过程其实就是依赖于如果发现是循环依赖的话，通过将对象提前暴露出来，存储缓存中，并且scope=singleton。所以可以解决这个问题。

Bean生命周期

- 动态注册bean的两种方式
- 实例化
- 初始化-循环依赖
- 使用
- 销魂

AOP原理

- AOP核心概念
- 创建AOP准备工作
- JDK动态代理原理
- Cglib原理
- AOP动态代理的实现流程

事务原理

IOC原理-刷新方法

- 容器刷新前的准备工作
- bean工厂的创建
- 加载BeanDefinition
- 执行BeanFactoryPostProcessor增强器
- 进行国际化配置
- 多播配置和监听器的初始化
- 实例化bean对象
- 实例化完成后的处理工作

Spring MVC原理

Spring中设计模式

springbootstart加载原理

## Spring-cloud

Nacos

OpenFeign

Gateway

sentinel

# 四.中间件
## RPC/注册中心

Zookeeper

## 网关/代理

Nginx

## NoSQL
## 缓存
### Redis

![](https://img-blog.csdnimg.cn/a0b5b20bd1224d06814f1410019461c8.png)

Redis基本命令

底层数据结构落地应用

- 数据类型低层源码分析
- bitMap、HyperLogLog

Redis高性能IO模型

- 单线程模型

IO多路复用

- select、poll、epoll

持久化

- AOF
- RDB

淘汰策略

- LRU

双写一致性

雪崩、击穿、穿透、预热

- 布隆过滤器


分布式锁

- Redission

高可用

Redis数据同步、复制

Redis哨兵机制

Redis哨兵集群

Redis切片集群

redis事务和数据库事务区别

## 消息队列

消息队列作用

- 异步、削峰、解耦、提升写性能

带来的问题

- 消息延迟、系统的复杂度、数据不一致（消息顺序、消息丢失、重复消费、消息挤压、高可用、高性能）

### Kafka

Kafka基础架构

- Broker->Topic->Partition->Partition Leader-> Partition Follower 
- 部署架构：单机模式/集群模式

分区机制

- 作用提升负载均衡、可伸缩能力、提升系统处理写性能
- 策略：随机、轮询、按消息键保序、其他策略

消息挤压如何处理

- 优化性能避免消息挤压
  - 发送端性能优化
    - 准备数据、序列化数据、之前的耗时
    - 发送消息和返回响应网络传输中的耗时
    - Broker处理消息的时延
  - 消费端性能优化
    - 优化消费端程序业务逻辑性能
    - 水平扩容，增加消费端并发数据。加机器，分区。
- 发送快了，消费变慢了
  - 监控、紧急消费端扩容、关闭上游系统功能、错误日志、同一条消息反复消费，拖垮整个系统

消息重复消费

- 生产者幂等、消费者幂等

消息可靠传输

- 发送、存储、消费三个阶段

生产者消费流程

Kafka如何实现高性能

- 批量发送、顺序读写提升磁盘IO性能、PageCache加速消息读写、零拷贝技术

**Kafka消费者分区分配和重平衡 ⭐️**

消费者位移

副本机制

Kafka多线程消费

Kafka高水位和Leader Epoch原理

### RabbitMQ

Pulsar



## 搜索引擎 
 ### ES

## 配置中心

### Apollo

- 部署架构
  - Config Service提供配置的读取、推送等功能，服务对象是Apollo客户端。
  - Admin Service提供配置的修改、发布等功能，服务对象是Apollo Portal（管理界面）。
  - Config Service和Admin Service都是多实例、无状态部署，所以需要将自己注册到Eureka中并保持心跳。
- 服务端设计
  - 配置发布后的实时推送设计
  - 发送ReleaseMessage的实现方式
  - Config Service通知客户端的实现方式
- 客户端设计
  - 长连接

### XDmond
## 定时

### XXL-JOB

## 监控/报警/日志

## 链路

### FalCon

# 五.软件设计

![img](https://static001.geekbang.org/resource/image/f3/d3/f3262ef8152517d3b11bfc3f2d2b12d3.png)

## 编程范式

类型系统

范型编程

面向过程

面向对象

- 封装、抽象、继承、多态
- 接口 VS 抽象类
- 封装-信息隐藏和数据访问保护
- 抽象-隐藏方法的具体实现，提高可拓展性、维护性、处理复杂系统的有效手段
- 继承-解决代码复用
- 多态-提高代码的拓展-复用

函数式编程

原型编程

编程本质

## 规范

编码规范

- 可维护性、可读性、可拓展性、灵活性、简洁性、可复用性、可测试性
- 多态、继承 写出可复用代码
- 编码规范写出可读性好的代码
- 设计原则指导写出可复用、灵活、可读性、易拓展、易维护代码
- 设计模式指导写出拓展性
- 持续重构->可维护性代码

## 重构

- 单元测试
- 可测试性
- 大重构
- 小重构

## 设计原则
单一职责原则-SRP

- 关于单一职责原则，其核心的思想是：一个类，只做一件事，并把这件事做好，其只有一个引起它变化的原因。单一职责原则可以看作是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而极大地损伤其内聚性和耦合度。单一职责，通常意味着单一的功能，因此不要为一个模块实现过多的功能点，以保证实体只有一个引起它变化的原因。
  - 实际生活：厕所、厨房 只负责一件事情。做饭

开闭原则-OCP

- OCP（Open/Closed Principle）- 开闭原则。关于开发封闭原则，其核心的思想是：模块是可扩展的，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改
  - 实现：接口、抽象、多态、设计模式等
  - 可拓展&过度设计。 可拓展&可读性 权衡利弊

里氏替换原则-LSP

- 子类对象可以替换程序中父类对象出现的任何地方，并且保证原有程序逻辑的正确性不被破坏
- 多态的区别，多态是面向对象编程中一个特性，是用来在具体代码实现的思路，但是里氏替换原则是一种设计原则，是用来指导继承关系中子类该如何设计，保证子类可以替换父类。
- 子类必须能够替换成它们的基类。即子类应该可以替换任何基类能够出现的地方，并且经过替换以后，代码还能正常工作。另外，不应该在代码中出现 if/else 之类对子类类型进行判断的条件。里氏替换原则 LSP 是使代码符合开闭原则的一个重要保证。正是由于子类型的可替换性才使得父类型的模块在无需修改的情况下就可以扩展。

接口隔离原则-ISP

- 单一职责针对的是模块、类、接口的设计，接口隔离原则更注重于接口的设计，提供了判断接口是否是单一职责的标准。

依赖倒置原则-DIP

- IOC 控制反转，控制是程序流程由原来的程序员控制，到框架控制整体流程，通过框架的预留点进行拓展实现业务需求。控制反转是一种设计思想，指导框架层面的控制。
- 依赖注入：其实就是不通过new的方式进行创建类。而是通过框架内部机制，直接使用。
- 依赖注入框架：Spring就负责将对象的创建、初始化、生命周期进行管理，我们只需要按照对应的配置就可以进行使用。
- 高层不依赖底层细节，高层和底层实现应该依赖于抽象，实现细节依赖于抽象。
  - Tomcat和应用 互相依赖于servlet规范

Don’t Repeat Yourself (DRY) 原则

Keep It Simple, Stupid (KISS)原则

Program to an interface, not an implementation

You Ain’t Gonna Need It (YAGNI) 原则

Law of Demeter，迪米特法则 (Law of Demeter)原则

## 设计模式

### 创建型

单例模式

工厂模式

建造者模式

原型模式

### 结构型

代理模式

桥接模式

装饰者模式

适配器模式

门面模式

组合模式

享元模式

- 目的：复用对象，节省内存，对象不可变
- 应用：Integer, Long 的缓存区 
- 和单例的区别
  - 单例是一个类只创建一个对象，享元模式是一个类可以创建多个对象，每个对象被多处代码引用共享。前者是限制对象的个数，后者是达到对象复用，节省内存

### 行为型

观察者模式

模板模式

- 模板模式的本质定义一个框架流程，具体的拓展点可以子类进行实现。具体的功能是复用和拓展，复用是指的是，所有的子类可以复用父类中提供的模板方法的代码，拓展是框架通过模板模式提供功能拓展点，用户不修改框架源码的情况下，基于拓展点就可以实现功能。

策略模式

- 解决if、else
- 定义、创建、使用

职责链模式

- 解决的是一个流程问题，通过不同的过滤器进行处理

迭代器模式

状态模式

访问模式

备忘录模式

命令模式

解释器模式

中介模式

## 源码解析

> 为什么学习源码
>
> - 大厂面试问
> - 提升阅读代码的功能、输出优质的代码、学习软件设计思想
> - 提升技术功底
> - 二次开发
> - 快速定位线上问题
> - 拥抱开源社区
>
> 前置基础知识
>
> - 设计模式、数据结构算法、反射、多线程
>
> 源码学习方式
>
> - 会使用、全局观、不要关注细节、看注释(类、方法、接口)、见名知意、大胆猜测、小心验证、画图、学习路径、坚持
> - 推荐路径 集合、并发、spring、mvc、mybatis、boot、Alibaba、bio->netty->kafka



集合

- ArrsyList 
- LinkedList

- hashmap   ✅
- concurrenthashmap
- CopyOnWriteArrayList
- LinkedHashMap

线程池  ❌

- ExecutorService ✅
- AbstractExecutorService ✅
- Executors ✅
- ScheduledThreadPoolExecutor 
- 阻塞队列
  - ArrayBlockingQueue.   ✅
  - LinkedBlockingQueue.  ✅
  - PriorityBlockingQueue 
  - DelayQueue
  - LinkedTransferQueue
  - SynchronousQueue

AQS

- Synchroneized. ✅
- ReentrantLock. ✅
  - ReentrantReadWriteLock
- Condition
- CountDownLatch
- CyclicBarrier
- Semaphore
- ThreadLocal

异步编程

- CompletableFuture

spring

- Bean加载
- 事务
- AOP
- 三级缓存
- Spring mvc
- spting boot
  - 自动装配

Spring mvc

mybaits

tomcat

netty

Dubbo

kafka

ZK

## DDD&MVC
# 六.架构设计

架构设计三原则、简单、合适、演化。**面向复杂度设计**
![img](https://img-blog.csdnimg.cn/a2e7e82a740c49d79c0d5f1d50cae3d4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXhseGk=,size_20,color_FFFFFF,t_70,g_se,x_16)
![img](https://img-blog.csdnimg.cn/2ab8c7fae2894781899ceac595beec6e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcXhseGk=,size_20,color_FFFFFF,t_70,g_se,x_16)

- ![image](https://github.com/qxlx/skill-tree/assets/36980092/df11e9cd-d3e5-4e49-93d8-4b72de63e0d2)
![image](https://github.com/qxlx/skill-tree/assets/36980092/b86f37cf-5a9f-4d37-a4e7-cab9bd595395)

## 微服务

演进

- 业务上演变->微服务(演进) 【进程内->进程间交互】
  - a.链路过长、问题所在的定位
  - b.机器问题  服务调用
  - c.粒度问题 如何切  抉择
- 难点
  - 分布式锁、事务
  - 开发以来下游，开发、测试沟通
  - 运维挑战、容器云
  - 性能问题 调度链路长 网络IO等

## 分布式理论

BASE

- **Basic Availability**：基本可用。这意味着，系统可以出现暂时不可用的状态，而后面会快速恢复。
- **Soft-state：**软状态。它是我们前面的“有状态”和“无状态”的服务的一种中间状态。也就是说，为了提高性能，我们可以让服务暂时保存一些状态或数据，这些状态和数据不是强一致性的。
- **Eventual Consistency：**最终一致性，系统在一个短暂的时间段内是不一致的，但最终整个系统看到的数据是一致的。

CAP

- 一致性 (Consistency)  **强调的是各节点间的数据一致**
- 可用性 (Availability)
- 分区容错性 (Partition Tolerance)  **强调的是集群对分区故障的容错能力**

ACID

ACID的目的其实是为了保证数据的一致性，但是这种一致性是强一致性，在单机系统下可以很好的实现，但是放在分布式系统中，我们很难去权衡系统之间可用和数据的强一致性。而[分布式事务]需要通过二阶段提交协议和TCC（Try-Confirm-Cancel）实现。

- 原子性（Atomicity）：整个事务操作过程中，要么是整体成功的，要么是整体失败的，不可能出现一半成功一半失败。如果出现异常的话，那么需要进行回滚到最原始的状态。举一个例子来说，比如我们在一个大事物中同时操作了订单和支付的表，那么当出现异常的情况，比如说三方异常或者是内部系统错误，事务会进行回滚到原始的状态。
- 一致性(Consistency）: 在事务执行的前后，数据的完整性约束没有破坏。
- 隔离性（Isolation）： 两个事务之间不会互相干扰，即一个事务A不会看到另一个事务B的中间数据。
- 持久性（Durability）： 当事务完成之后，数据会被持久化到磁盘中，并且出现机器宕机等可以进行数据的恢复

我们知道在分布式系统中不同的业务其实并不需要完全的数据一致性，大对数场景中，我们必须保证的是核心链路的稳定性、可用性，所以BASE其实就是CAP的一个变种。倾向于设计出一个更富有弹性能力的系统。
在分布式系统中故障是不可避免的，当出现分区或者故障的时候，我们应该在设计层面多去考虑可能出现的问题，把故障处理当成功能写入代码中，即Design for Failure。新手与老手的差别就是新手可能会完整基本功能就可以了，但是老手会考虑很多边界问题，不和合法性以及可能出现的各种异常问题。
举一个例子：比如买书，ACID的玩法是将库存锁住，不可能同时多个用户购买，而BASE的玩法是异步处理，可以支持用户抢购。
ACID是酸、BASE是碱，从本质上来说ACID的C强调的是一致性（CAP中C），而BASE强调的是可用性（CAP中A）
关注点也不一样：ACID关注的是数据的完整性，而CAP的C关注的是分布式节点的数据一致性。

![在这里插入图片描述](https://img-blog.csdnimg.cn/eb065973d6d94c36a988d4cfcbd36f14.png)

FLP

- 很多人知道CAP、ACID、BASE 但是却不了解FLP，这里为了文章的完整性，介绍一下

  FLP是分布式领域中非常著名的定理，在异步通讯场景中，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性。

  限定条件

- 确定性协议：给定一个输入，一定会产生相同的输出。
- 异步网络通讯：同步通信：同时在线，允许超时，异步通信，没有统一时钟，不能时间同步，不能使用超时，消息可任意延时，乱序。
- 所有存活节点：所有存活的节点必须最终到达一致性。

**ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸**

![在这里插入图片描述](https://img-blog.csdnimg.cn/01f53a6786694d9480f4407be644fd41.png)

两将军

- 两将军问题，主要描述的是有两个军队A和B，分别驻扎在山谷的两侧，同时进攻城市。但是两个军队进攻时间是不确定的，也就是两边军队的Leader没有对发起进攻的时间形成一致。如果任意一方发起，另一方不发起进攻，那么就会失败。想要达成共识的办法就是通过发送信使的通知对方，但是中间的山谷被敌军占领。

  假设军队Aleader指派了一名通讯兵去通知军队B 明天8点发起进攻，但是很可能这个通讯兵在中途被敌军擒获。如果没有擒获的话，军队Bleader为保证自己收到消息，需要给军队A发送消息，我已经收到了明天8点一起发起总攻。但是这个通讯兵在路上也可能被擒获。即使两边一次不停的发送也没有办法保证消息自己的通讯兵没有被擒获。所以这个问题是无解的。

  说白了，在两将军问题中，信道是不可靠的，但是如果从工程角度解决的话，并不会去尝试解决信道不可靠问题，而是将这个不可靠降低到一个可接受的程度，三次握手机制其实是没有办法保证网络连接的可靠性，只是说在基于网络连接可靠的情况下，通过客户端和服务端的请求-相应-确认机制去确保连接建立成功。

拜占庭将军

- 拜占庭问题其实描述的是在拜占庭，周边有多个军队，想要一起进攻，必须每个军队就进攻/不进攻达成一致，但是再次基础上，军队中存在敌军间谍，会扰乱左右决策的过程，从而导致最终结果不一致。说白了拜占庭问题就是，在已知有敌军间谍的情况下，在忠勇将军的不受判读的影响下如何达成一致的协议。
  拜占庭将军问题是两将军问题的升级版本，除了存在故障行为，还可能存在恶意行为。所以一般使用的话在数字货币的区块链技术中需要使用拜占庭容错算法。BFT。

## 共识算法

一致性与共识

- 分布式共识就是在多个节点均可独自操作或记录的情况下，使得所有节点针对某个状态达成一致的过程。通过共识机制，我们可以使得[分布式系统]中的多个节点的数据达成一致。
- **一致性强调的是结果，共识强调的是达成一致的过程**

Paxos

Raft

ZAB

Gossip

## 分布式计算

## 分布式存储

分布式ID

分片

- **分片或者分区的本质是为了解决单机存储和性能瓶颈带来的问题，让分布式系统的计算和存储能力可以线性扩展。而数据复制解决的是数据的高可用**
- 水平分片/ 垂直分片 / 混合分片
- 算法：范围分片、哈希分片、一致性哈希分片、**基于虚拟节点的一致性哈希算法**

复制

- **为保证高可用，数据复制就会涉及到数据之间的拷贝，也就是数据一致性问题**
- 单主复制（同步、异步、半异步复制）
- 多主复制
- 无主复制

事务

**CP+ACID=》刚性事务  适用于数据层** 

**AP+BASE=> 柔性食物  适用于业务层**

- XA 

  - 2PC ：准备、提交

  - 3PC：准备、预提交、提交

- 业务补偿
  - TCC
  - sega
- 最终一致性
  - 消息表
  - 消息队列
  - 最大努力通知

分布式锁

- Redis
- ZK
- MySQL

数据存储和检索

- B+树 ：读多写少
- LSM ：写多读少
- 倒排索引&PageRank ：数据搜索

## 高性能架构

![img](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/assets/a9edeae125a80f381003d8d9d0056317.png)

- 缓存

  从客户端、CDN、网关、服务端、内存、数据库、文件系统、磁盘和CPU 都可以通过加缓存，来提高访问的速度。

- 负载均衡

  水平拓展的技术，通过将用户请求分发到不同的机器上来承担一部分用户流量

- 异步调用

  主要通过消息队列来实现，将前段的请求的峰值给肖平，后端按照自己的速度进行处理请求，增加系统的吞吐量，但是实时性就比较差。但是消息队列带来了消息丢失，重复消费，消息挤压等问题。

- 数据分区/镜像

  数据分区是通过将数据按照某种维度进行划分，比如地理上，请求最近的数据，但是join和跨库的事务操作复杂度比较高。而数据镜像则是通过将数据拷贝一份，然后任意节点上都可以读写，内部自行同步数据，最大问题就是数据一致性问题。

  

  缓存是提高读的性能，而异步调用是提高写的性能，负载均衡技术主要是通过服务冗余将流量进行分担，在分布式架构中，数据存储是一个重中之重，而一般要么就是使用镜像/复制技术，将数据进行拷贝，读写分离，另一种就是将数据分成多片，每片存储在不同服务器上，这样可以横行提高数据读写能力

## 高可用架构

![img](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/assets/befd21e1b41a257c5028f8c1bc7fa279.png)

- 服务拆分

  服务拆分的目的主要是两个，一是隔离故障，二是提高重用性。但是拆分后会引来服务之间依赖通信问题

- 服务冗余

  去除单点故障，支持服务的弹性伸缩，以及故障迁移。具体形式可能是主备、主从。

- 限流降级

  当系统是在扛不住压力的时候，需要通过限流或者降级的方式来保证核心业务的正常运转，属于技术保护的措施。

  接口级别：限流、降级、排队、熔断、超时重试&幂等

- 高可用架构

  通常来说高可用架构是从冗余架构的角度来保证可用性，多租户隔离，容灾备份(异地多活/同城多机房、跨城多机房、跨国多机房)，或者数据可以在复制保持一致性的集群。

  异地多活：同城多机房、跨城多机房、跨国数据中心

  存储高可用：复制（主从、主备、主主）

  计算高可用：负载均衡、任务分配、任务分解

- 高可用运维

  DevOps中的CI/CD（持续集成、持续部署）一个流程的软件发布流程，足够的自动化测试，相应的灰度发布，线上系统的自动化控制。

## 分布式系统的纲

![img](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/assets/8958a432f32dd742b6503b60f97cc3f2.png)



- **服务治理**

  服务拆分、服务调用、服务发现、服务依赖。关键在于对服务调用链路，依赖关系给梳理出来，并对这些服务进行性能和可用性方面的管理

- **软件架构管理**

  服务之间有依赖关系，有兼容性问题，所以整体服务所形成的架构需要有架构版本管理，整体架构的生命周期管理，以及对服务的编排，聚合，事务处理等服务调度功能

- **DevOps**

  分布式服务可以快读的部署，但是对测试和运维是一个挑战，包括环境构建、持续集成、持续部署等

- **自动化运维**

  对服务进行自动伸缩、故障迁移、配置管理、状态管理等一系列自动化运维技术了

- **资源调度管理**

  应用层的 计算 网络 存储

- **整体架构监控**

  监控是眼睛，需要对 应用层、中间件层、基础层进行监控

- **流量控制**

  负载均衡、服务路由、熔断、限流、降级都和流量相关的调度，以及灰度发布等。

分布式五个关键技术

- 全栈系统监控
- 服务、资源调度
- 流量调度
- 状态、数据调度
- 开发和运维的自动化

## 可拓展架构

分层

SOA

微服务

微内核

## 性能调优

- 客户端-服务端 数据流走向  web->dns->nginx->tomcat->三方进程->DB

性能指标

- TPS、QPS、吞吐量

架构设计

- 缓存、异步、集群、分片、复制
- 网络层面
- 服务器硬件层面
- 操作系统层面
- JVM性能优化
- 基础组件优化（MySQL、Kafka、Redis）
- 软件架构层面优化
- 软件代码优化

如何优化

- 三要三不要
  - 三要
    - 查询系统最大性能瓶颈
    - 确诊问题根本原因
    - 考虑多种情况
  - 三不要
    - 过度反常优化
    - 过早不成熟优化
    - 表面的肤浅优化
- 十大策略
  - 时空转换
    - 空间换时间
    - 时间换空间
  - 并行/异步
    - 并行操作
    - 异步操作
  - 预先/延后处理
    - 预先/提前处理
    - 延后/惰性处理
  - 缓存/批量合并
    - 缓存数据和结果
    - 合并和批处理
  - 算法设计和数据结构
    - 更快的算法设计
    - 更优化的数据结构
- 线程池
  - 数据库连接池
  - Redis连接池
  - 网络连接池
  

## 系统设计

# 七.编程工具

## git

## idea

## Maven

## gradle

# 八.云原生

## CI/CD

软件生命周期

CI/CD

Jenkins

## DevOps

## docker

基本组件

- 镜像

- 容器

  - ds

  - 为什么隔离

    - 系统安全、资源隔离

  - 虚拟机的区别

    用虚拟机实现与宿主机的强隔离，然后在虚拟机里使用Docker容器来快速运行应用程序。

    - |        | 实现方式                     | 优势                     | 劣势               |
      | ------ | ---------------------------- | ------------------------ | ------------------ |
      | 虚拟机 | 虚拟化硬件                   | 隔离程度非常高           | 资源消耗大，启动慢 |
      | 容器   | 直接利用下层的硬件和操作系统 | 资源利用率高，运行速度快 | 隔离程度低         |

      隔离实现原理

      - namespace、cgroup、chroot

- 仓库

常用命令

- docker version  //查看命令
- docker run hello-world //运行hello world
- systemctl stop docker  //停止
- systemctl start docker  //启动
- systemctl restart docker //重启

容器数据卷

compose

container

network

image

volume

swarm

## k8s



# 九.大数据
  实时计算
  离线计算

## Hadoop

## Spark\Filnk

# 十.其他领域

## 区块链     

# 终极篇-技术管理

## 1.总体介绍

技术的本质：技术是为了解决问题，技术解决问题的一种手段。

三角：技术->业务->产品

技术团队管理的本质 

- 带好团队
- 做好事
- 团队文化

管理思维｜技术思维

- 系统性思维、利他思维、用户思维、trade-off思维

技术管理的能力构成

- 自我管理、商业思维、向上管理、产品思维、同级别管理、跨部门协作、数据思维、业务洞察力、技术敏感和架构决策、项目管理、

## 2.思维方式篇

闭环思维：事情有开始有结尾。

- Plan->Do->Check->Act 



## 3.制度篇

## 4.人才篇

## 5.团队篇

## 6.组织设计篇

## 7.做事篇

1.做事认知

- 做事是第一重要的事
- 做事在很多公司被定义做项目或者产品迭代
- 做事流程分为：事前、事中、事后
  - 事前
    - 我们要做哪些事？哪件先做？优先级？
  - 事中
    - 如何保证事按照我们计划顺利执行
  - 事后
    - 复盘抽象出机制以便在相同场景中应用

2.如何正确做事

- 事情优先级
- 计划外的事情
  - 生产故障 优先级最高
  - 需求类，排期
- 收益 vs 损失
- 回归目标本质、沟通 
  - 延期、知会、不要给leader 惊喜、产品侧同步

3.执行到位

- 目标明确：基于smart原则，是否传达团队所有人员，变更同步。
- 职责清晰：owner  研发 产品 等
- 健全的机制
- 团队人员达成共识和重要节点变更通报 

4.流程机制

- 设置关键检查点
  - 接口设计涵盖功能性和非功能性
  - 接口设计review
  - 上线前检查   CR

## 8.研发工具效率篇

## 9.技术判断力与决策篇

## 10.自我修养篇

## 11.项目管理篇

## 12.产品篇

## 13.商业思维篇

## 14.管理者能力认识篇

## 15.数据思维篇

# 面试

工作中遇到的那些问题、难点 系统架构图         

     操作系统
       https://segmentfault.com/a/1190000039774784 从根上理解用户态与内核态



**极客时间看完->读经典书籍**

- 
