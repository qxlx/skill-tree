## 刷题指北

## 【数据结构】

## 数组

- [ ] 283.移动零         1、loop  2、滚雪球 3、0和n[i]交换位置

- [ ] 70.爬楼梯            1、递归   2、记忆化递归   3、dp   4、循环

- [ ] 二数之和              1、暴力解  2、Hash     ✅ 

- [ ] 三数之和              1、暴力解  2、哈希表    3、夹逼法(双指针)

- [ ] 7.整数反转           1、 %10 取余数  /10取整数部分。 越界判断

- [ ] 48.旋转图像         1、先右上角和左下角为一条线 进行对其，交换数据。  中间上下交换数据。注意边界条件。

- [ ] 939.最小面积矩阵  1、通过计算最小对角线 注意边界 i j的取值

  

## 双指针

- [ ] 202.快乐数  		1、快慢指针
- [ ] 11.盛水问题        1、枚举  2、双指针左右夹逼







## 队列

- [ ] 239.滑动窗口最大值    


## 栈

- [ ] 20.有效的括号   
- [ ] 155.最小栈
- [ ] 84.柱状图中最大的矩形
- [ ] 栈实现队列 
- [ ] 队列实现栈      



## 哈希表

- [ ] 454.四数相加   1、HashMap存储AB的正值 用CD的负值去查找
- [ ] 242.有效的字母异位词  1.先排序 在比较 2.用一个字母数组进行计算 一个加 一个减 如果数组中有一个不是0 返回false
- [ ] 49.字母异位词分组  1.一个map  将字符串转换字符数组 排好序之后，key 按照key进行排序。

## 树

- [ ] 94.二叉树的中序遍历   1.递归 左中右  2,栈结构 左中右push pop 
- [ ] 99.恢复二叉搜索树  中序 1.迭代 2.递归

## 字符串

- [ ] 13. 罗马数字转整数  1.判断前一位树和后一位数大小 大于 做加法，小于做减法。
- [ ]  14.最长公共前缀   1.拿到第一个字符串 for for去和后续的字符串进行匹配。不等直接返回。ans 截取。
- [ ]  28.实现strStr() 1.双指针 i指向长字符串 j指向短字符串 for for 遍历。

## 【算法】

## 递归

- [ ] 22.括号生成  1.递归 left，right 分别加左右括号 同时在递归的过程中排除不符合的条件。
- [ ] 98.验证搜索二叉树 1.递归 中序遍历 2.递归 root的左子树的最大值是否大于根节点  root的右子树的最小值是否小于根节点
- [ ] 104.二叉树的最大深度  1.递归 `Math.max(maxDepth(root.left),maxDepth(root.right))+1;`
- [ ] 111.二叉树的最小深度  1.递归 `(leftDepth == 0 || rightDepth == 0) ? leftDepth+rightDepth+1 : Math.min(leftDepth,rightDepth)+1; `
- [ ] 415.字符串相加  1.进位 `carry=sum/10` `num = sum %10`



## DFS

- [ ] 289.生命游戏      1.分别遍历每个位置的8个方位。dfs就可以。
- [ ] 78.子集                 1.dfs+回溯
- [ ] 200.岛屿数量       1.感染1为2 然后dfs查找
- [ ] 130.被围绕的区域   1.通过边界查找，查找到的O 设置为 #  如果dfs之后，还有o 那么就是被x围绕的 设置成x
- [ ] 102.二叉树的层序遍历   1.bfs+queue    2.dfs

## 分治

- [ ] 50.pow(x,n)      1.分治  通过将结果进行求取。 最后判断n==1 多乘一个x

## 回溯

- [ ] 79.单词搜索   1.dfs 上下左右四个方向查找
- [ ] 212.单词搜索-2   1.dfs    2.Trie树
- [ ] 17.电话号码的字母组合  1.回溯
- [ ] 93.复原ip地址  1.暴力求解 2.回溯



## LRU

- [ ] 146.LRU缓存机制  1.hashtable+双链表

## 位运算

- [ ] 191.1的个数  1.n&=(n-1)  2.`count+=n&1`
- [ ] 231.2的幂  1. `(n>0)&&((n&(n-1)) == 0)`
- [ ] 
